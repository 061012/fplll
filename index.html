<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>fplll: fplll</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">fplll 5.0.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">fplll </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/fplll/fplll"></a></p>
<p>fplll contains implementations of several lattice algorithms. The implementation relies on floating-point orthogonalization, and LLL [LLL82] is central to the code, hence the name.</p>
<p>It includes implementations of floating-point LLL reduction algorithms [NS09,MSV09], offering different speed/guarantees ratios. It contains a 'wrapper' choosing the estimated best sequence of variants in order to provide a guaranteed output as fast as possible [S10]. In the case of the wrapper, the succession of variants is oblivious to the user.</p>
<p>It includes an implementation of the BKZ reduction algorithm [SE94], including the BKZ-2.0 [CN11] improvements (extreme enumeration pruning, pre-processing of blocks, early termination). Additionally, Slide reduction [GN08] and self dual BKZ [MW16] are supported.</p>
<p>It also includes a floating-point implementation of the Kannan-Fincke-Pohst algorithm [K83,FP85] that finds a shortest non-zero lattice vector. For the same task, the <a class="el" href="classGaussSieve.html">GaussSieve</a> algorithm [MV10] is also available in fplll. Finally, it contains a variant of the enumeration algorithm that computes a lattice vector closest to a given vector belonging to the real span of the lattice.</p>
<p>fplll is distributed under the [GNU Lesser General Public License](COPYING) (either version 2.1 of the License, or, at your option, any later version) as published by the Free Software Foundation.</p>
<h3>How to cite</h3>
<pre class="fragment">@unpublished{fplll,
    Note = {Available at \url{https://github.com/fplll/fplll}},
    Title = {{fplll}, a lattice reduction library},
    Author = {The {FPLLL} development team},
    Year = 2016,
    url = {https://github.com/fplll/fplll}
}
</pre><h2>Dependencies</h2>
<h3>Required</h3>
<ul>
<li>GNU MP 4.2.0 or higher <a href="http://gmplib.org/">http://gmplib.org/</a></li>
<li>MPFR 2.3.0 or higher, COMPLETE INSTALLATION <a href="http://www.mpfr.org/">http://www.mpfr.org/</a></li>
<li>autotools 2.61 or higher</li>
<li>g++ 4.9.3 or higher</li>
</ul>
<p>If GMP and/or MPFR include and lib files are not in the default directories <code>/usr/include</code> and <code>/usr/lib</code>, you have to set the environment variables <code>CFLAGS</code> and <code>LDFLAGS</code> for instance through the configure command line </p><pre class="fragment">./configure CPPFLAGS="-I/mpfrinclude -I/gmpinclude" LDFLAGS="-L/mpfrlib -L/gmplib"
</pre><p>or </p><pre class="fragment">./configure CPPFLAGS="-I/mpfrinclude -I/gmpinclude $CPPFLAGD" LDFLAGS="-L/mpfrlib -L/gmplib $LDFLAGS"
</pre><p>if these variables already exist in your environment. This should be modified soon for using standard <code>--with-gmp</code> and <code>--with-mpfr</code> package specifications. The same philosophy applies to the (optional) QD library.</p>
<h3>Optional</h3>
<ul>
<li>QD 2.3.15 or higher (a C++/Fortran-90 double-double and quad-double package), compile and install the shared library (e.g., <code>./configure --enable-shared=yes</code>). <a href="http://crd-legacy.lbl.gov/~dhbailey/mpdist/">http://crd-legacy.lbl.gov/~dhbailey/mpdist/</a></li>
</ul>
<h2>Installation</h2>
<p>You should downloaded the source code from github and then run </p><pre class="fragment">./autogen.sh
</pre><p>which generates the <code>./configure</code> script used to configure fplll by calling the appropriate autotools command.</p>
<p>Then, to compile and install type </p><pre class="fragment">./configure
make
make install            # (as root)
</pre><p>You can remove the program binaries and object files from the source code directory by typing <code>make clean</code>. To also remove the files that <code>./configure</code> created (so you can compile the package for a different kind of computer), type <code>make distclean</code>. By default, <code>make install</code> installs the package commands under <code>/usr/local/bin</code>, include files under <code>/usr/local/include</code>, etc. You can specify an installation directory name other than <code>/usr/local</code> by giving <code>./configure</code> the option <code>--prefix=dirname</code>. Run <code>./configure --help</code> for further details.</p>
<h2>Check</h2>
<p>Type </p><pre class="fragment">make check
</pre><h2>How to use</h2>
<p>Executable files <code>fplll</code> and <code>latticegen</code> are installed in the directory <code>/usr/local/bin</code>. (Note that the programs generated by <code>make</code> in the <code>fplll/</code> directory are only wrappers to the programs in <code>fplll/.libs/</code>).</p>
<p>If you type <code>make check</code>, it will also generate the executable file <code>llldiff</code>, in <code>fplll/.libs/</code>.</p>
<h3>latticegen</h3>
<p><code>latticegen</code> is a utility for generating matrices (rows form input lattice basis vectors).</p>
<p>The options are:</p>
<ul>
<li><code>r</code> <code>d</code> <code>b</code> : generates a knapsack like matrix of dimension d x (d+1) and b bits (see, e.g., [S09]): the i-th vector starts with a random integer of bit-length &lt;=b and the rest is the i-th canonical unit vector.</li>
<li><code>s</code> <code>d</code> <code>b</code> <code>b2</code> : generates a d x d matrix of a form similar to that is involved when trying to find rational approximations to reals with the same small denominator (see, e.g., [LLL82]): the first vector starts with a random integer of bit-length &lt;=b2 and continues with d-1 independent integers of bit-lengths &lt;=b; the i-th vector for i&gt;1 is the i-th canonical unit vector scaled by a factor 2^b.</li>
<li><code>u</code> <code>d</code> <code>b</code> : generates a d x d matrix whose entries are independent integers of bit-lengths &lt;=b.</li>
<li><code>n</code> <code>d</code> <code>b</code> <code>c</code> : generates an ntru-like matrix. If char is 'b', then it first samples an integer q of bit-length &lt;=b, whereas if char is 'q', then it sets q to the provided value. Then it samples a uniform h in the ring Z_q[x]/(x^n-1). It finally returns the 2 x 2 block matrix [[I, Rot(h)], [0, q*I]], where each block is d x d, the first row of Rot(h) is the coefficient vector of h, and the i-th row of Rot(h) is the shift of the (i-1)-th (with last entry put back in first position), for all i&gt;1. Warning: this does not produce a genuine ntru lattice with h a genuine public key (see [HPS98]).</li>
<li><code>N</code> <code>d</code> <code>b</code> <code>c</code> : as the previous option, except that the contructed matrix is [[q*I, 0], [Rot(h), I]].</li>
<li><code>q</code> <code>d</code> <code>k</code> <code>b</code> <code>c</code> : generates a q-ary matrix. If char is 'b', then it first samples an integer q of bit-length &lt;=b; if char is 'p', it does the same and updates q to the smallest (probabilistic) prime that is greater; if char is 'q', then it sets q to the provided value. It returns a 2 x 2 block matrix [[I, H], [0, q*I]], where H is (d-k) x k and uniformly random modulo q. These bases correspond to the SIS/LWE q-ary lattices (see [MR09]). Goldstein-Mayer lattices correspond to k=1 and q prime (see [GM03]).</li>
<li><code>t</code> <code>d</code> <code>f</code> : generates a d x d lower-triangular matrix B with B_ii = 2^(d-i+1)^f for all i, and B_ij is uniform between -B_jj/2 and B_jj/2 for all j&lt;i.</li>
<li><code>T</code> <code>d</code> : also takes as input a d-dimensional vector vec read from a file. It generates a d x d lower-triangular matrix B with B_ii = vec[i] for all i and B_ij is uniform between -B_jj/2 and B_jj/2 for all j&lt;i.</li>
</ul>
<p>The generated matrix is printed in stdout.</p>
<p>Note that by default, the random bits always use the same seed, to ensure reproducibility. The seed may be changed with the option <code>-randseed &lt;integer&gt;</code> or by using the current time (in seconds) <code>-randseed time</code>. If you use this option, it must be the first one on the command line.</p>
<h3>fplll</h3>
<p><code>fplll</code> does LLL, BKZ, HKZ or SVP on a matrix (considered as a set of row vectors) given in stdin or in a file as parameter.</p>
<p>The options are:</p>
<ul>
<li><code>-a lll</code> : LLL-reduction (default).</li>
<li><code>-a bkz</code> : BKZ-reduction.</li>
<li><code>-a hkz</code> : HKZ-reduction.</li>
<li><code>-a svp</code> : prints a shortest non-zero vector of the lattice.</li>
<li><code>-a sdb</code> : self dual variant of BKZ-reduction.</li>
<li><code>-a sld</code> : Slide reduction.</li>
<li><code>-a svp</code> : print a shortest vector of the lattice.</li>
<li><code>-v</code> : verbose mode.</li>
<li><code>-nolll</code> : does not apply to LLL-reduction. In the case of bkz, hkz and svp, by default, the input basis is LLL-reduced before anything else. This option allows to remove that initial LLL-reduction (note that other calls to LLL-reduction may occur during the execution).</li>
<li><code>-r</code> <code>size</code>, <code>-c</code> <code>size</code> : ignored, provided for compatibility with previous versions of fplll.</li>
</ul>
<p><a class="el" href="structOptions.html">Options</a> for LLL-reduction:</p>
<ul>
<li><code>-d delta</code> : δ (default=0.99)</li>
<li><code>-e eta</code> : η (default=0.51). See [NS09] for the definition of (δ,η)-LLL-reduced bases.</li>
<li><code>-l lovasz</code> : if !=0 Lovasz's condition. Otherwise, Siegel's condition (default: Lovasz). See [A02] for the definition of Siegel condition.</li>
<li><code>-f mpfr</code> : sets the floating-point type to MPFR (default if <code>m=proved</code>).</li>
<li><code>-p precision</code> : precision of the floating-point arithmetic, works only with <code>-f mpfr</code>.</li>
<li><code>-f dd</code> : sets the floating-point type to double-double.</li>
<li><code>-f qd</code> : sets the floating-point type to quad-double.</li>
<li><code>-f dpe</code> : sets the floating-point type to DPE (default if <code>m=heuristic/heuristicearly</code>).</li>
<li><code>-f double</code> : sets the floating-point type to double (default if <code>m=fast/fastearly</code>).</li>
<li><code>-f longdouble</code> : sets the floating-point type to long double.</li>
<li><code>-z int</code> : sets the integer type to int.</li>
<li><code>-z mpz</code> : sets the integer type to mpz, the integer type of GMP (default).</li>
<li><code>-z double</code> : sets the integer type to double.</li>
<li><code>-m wrapper</code> : uses the wrapper. (default if <code>z=mpz</code>).</li>
<li><code>-m fast</code> : uses the fast method, works only with <code>-f double</code>.</li>
<li><code>-m fastearly</code> : uses the fast method with early reduction, works only with <code>-f double</code>.</li>
<li><code>-m heuristic</code> : uses the heuristic method.</li>
<li><code>-m heuristicearly</code> : uses the heuristic method with early reduction.</li>
<li><code>-m proved</code> : uses the proved version of the algorithm.</li>
</ul>
<p>With the wrapper or the proved version, it is guaranteed that the basis is LLL-reduced with δ'=2×δ-1 and η'=2×η-1/2. For instance, with the default options, it is guaranteed that the basis is (0.98,0.52)-LLL-reduced.</p>
<p><a class="el" href="structOptions.html">Options</a> for BKZ-reduction:</p>
<ul>
<li><code>-b block_size</code> : Block size, mandatory, between 2 and the number of vectors.</li>
<li><code>-f float_type</code> : Same as LLL (<code>-p</code> is required if <code>float_type=mpfr</code>).</li>
<li><code>-p precision</code> : Precision of the floating-point arithmetic with <code>-f mpfr</code>.</li>
<li><code>-bkzmaxloops loops</code> : Maximum number of full loop iterations.</li>
<li><code>-bkzmaxtime time</code> : Stops after <code>time</code> seconds (up to completion of the current loop iteration).</li>
<li><code>-bkzautoabort</code> : Stops when the average slope of the log ||b_i*||'s does not decrease fast enough.</li>
</ul>
<p>Without any of the last three options, BKZ runs until no block has been updated for a full loop iteration.</p>
<ul>
<li><code>-bpre block_size</code> : Pre-processing block size. Between 2 and the block size.</li>
<li><code>-bkzlinearpruning level</code> : Enables linear pruning in enumeration, such that the last level steps drop with slope -1/block_size.</li>
<li><code>-bkzghbound factor</code> : Multiplies the Gaussian heuristic by factor (of float type) to set the enumeration radius of the SVP calls.</li>
<li><code>-bkzboundedlll</code> : Restricts the LLL call before considering a block to vector indices within that block.</li>
<li><code>-bkzdumgso file_name</code> : Dumps the log ||b_i*|| 's in specified file.</li>
</ul>
<h3>llldiff</h3>
<p><code>llldiff</code> compares two bases (b1,...,bd) and (c1,...c_d'): they are considered equal iff d=d' and for any i, bi = +- ci. Concretely, if basis B is in file 'B.txt' and if basis C is in file 'C.txt' (in the fplll format), then one may run <code>cat B.txt C.txt | ./llldiff</code>.</p>
<h3>latsieve</h3>
<p><code>latsieve</code> does (tuple) lattice sieve on a matrix (considered as a set of row vectors) given in a file as parameter. You may compile it by using <code>make latsieve</code>. It will generate the executable file <code>latsieve</code> in <code>fplll/</code> which is a wrapper of <code>fplll/.libs/latsieve</code>.</p>
<p>The options are:</p>
<ul>
<li><code>-a nnn</code> : nnn is the tuple algorithm to use (default 2 corresponding to <a class="el" href="classGaussSieve.html">GaussSieve</a>)</li>
<li><code>-f filename</code> : follows input matrix</li>
<li><code>-b nnn</code> : BKZ preprocessing of blocksize nnn (optional)</li>
<li><code>-t nnn</code> : targeted square norm for stoping sieving (optional)</li>
<li><code>-s nnn</code> : using seed=nnn (optional)</li>
<li><code>-v</code> : verbose toggle</li>
</ul>
<h3>How to use as a library</h3>
<p>See <a href="https://fplll.github.io/fplll/">API documentation</a>.</p>
<h3>Alternative interfaces</h3>
<ul>
<li><a href="https://github.com/malb/fpylll">fpylll</a> is a stand-alone Python interface for fplll.</li>
<li>fplll is included in <a href="http://sagemath.org">Sage</a>, see documentation for <a href="http://doc.sagemath.org/html/en/reference/matrices/sage/matrix/matrix_integer_dense.html">IntegerMatrix</a> and <a href="http://doc.sagemath.org/html/en/reference/modules/sage/modules/free_module_integer.html">IntegerLattice</a>.</li>
</ul>
<h2>Examples</h2>
<ol type="1">
<li>LLL reduction</li>
</ol>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./latticegen r 10 1000 | ./fplll</div></div><!-- fragment --><ol type="1">
<li>Fileinput for reduction. If the file <code>matrix</code> contains</li>
</ol>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[[ 10 11]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;[11 12]]</div></div><!-- fragment --><p>then</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./fplll matrix</div></div><!-- fragment --><p>produces</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[[0 1 ]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; [1 0 ]</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;]</div></div><!-- fragment --><ol type="1">
<li>Random generator</li>
</ol>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./latticegen -randseed 1234 r 10 1000 | ./fplll</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;./latticegen -randseed time u 10 16 | ./fplll</div></div><!-- fragment --><ol type="1">
<li>Solving SVP</li>
</ol>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./latticegen r 30 3000 | ./fplll -a svp</div></div><!-- fragment --><h2>Bibliography</h2>
<p>[A02] A. Akhavi. Random lattices, threshold phenomena and efficient reduction algorithms. Theor. Comput. Sci. 287(2): 359-385 (2002)</p>
<p>[Chen13] Y. Chen, Lattice reduction and concrete security of fully homomorphic encryption.</p>
<p>[CN11] Y. Chen and P. Q. Nguyen. BKZ 2.0: Better Lattice Security Estimates. ASIACRYPT 2011: 1-20</p>
<p>[GM03] D. Goldstein and A. Mayer. On the equidistribution of Hecke points. Forum Mathematicum, 15:165–189 (2003)</p>
<p>[GN08] N. Gama and P. Q. Nguyen. Finding Short Lattice Vectors within Mordell's Inequality. STOC 2008: 207-216</p>
<p>[GNR13] N. Gama, P. Q. Nguyen and Oded Regev. Lattice <a class="el" href="classEnumeration.html">Enumeration</a> Using Extreme <a class="el" href="classPruning.html">Pruning</a>.</p>
<p>[HPS98] J. Hoffstein, J. Pipher, J. H. Silverman. NTRU: A Ring-Based Public Key Cryptosystem. ANTS 1998: 267-288</p>
<p>[K83] R. Kannan. Improved algorithms for integer programming and related lattice problems. STOC 1983, 99-108</p>
<p>[FP85] U. Fincke and M. Pohst. Improved methods for calculating vectors of short length in a lattice, including a complexity analysis. Math. Comp., 44(170):463–471 (1985)</p>
<p>[LLL82] A. K. Lenstra, H. W. Lenstra, Jr. and L. Lovasz. Factoring polynomials with rational coefficients. Math. Ann., 261: 515–534 (1982)</p>
<p>[MSV09] I. Morel, D. Stehle and G. Villard. H-LLL: using Householder inside LLL. ISSAC 2009: 271-278</p>
<p>[MV10] D. Micciancio and P. Voulgaris. Faster Exponential Time Algorithms for the Shortest Vector Problem. SODA 2010: 1468-1480</p>
<p>[MW16] D. Micciancio and M. Walter. Practical, Predictable Lattice Basis Reduction. EUROCRYPT 2016: 820-849</p>
<p>[MR09] D. Micciancio and O. Regev. Post-Quantum Cryptography. Chapter of Lattice-based Cryptography, 147-191 (2009)</p>
<p>[NS09] P. Q. Nguyen and D. Stehle. An LLL Algorithm with Quadratic Complexity. SIAM J. Comput. 39(3): 874-903 (2009)</p>
<p>[S10] D. Stehle. Floating-Point LLL: Theoretical and Practical Aspects. The LLL Algorithm 2010: 179-213</p>
<p>[SE94] C.-P. Schnorr and M. Euchner. Lattice basis reduction: Improved practical algorithms and solving subset sum problems. Math. Program. 66: 181-199 (1994)</p>
<h2>Credit</h2>
<h3>Maintainers</h3>
<p>fplll is currently maintained by:</p>
<ul>
<li>Martin Albrecht, <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'ti'+'nra'+'lb'+'rec'+'ht'+'@go'+'og'+'lem'+'ai'+'l.c'+'om'; return false;">marti<span style="display: none;">.nosp@m.</span>nral<span style="display: none;">.nosp@m.</span>brech<span style="display: none;">.nosp@m.</span>t@go<span style="display: none;">.nosp@m.</span>oglem<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a></li>
<li>Shi Bai, <a href="#" onclick="location.href='mai'+'lto:'+'shi'+'.b'+'ai@'+'gm'+'ail'+'.c'+'om'; return false;">shi.b<span style="display: none;">.nosp@m.</span>ai@g<span style="display: none;">.nosp@m.</span>mail.<span style="display: none;">.nosp@m.</span>com</a></li>
</ul>
<h3>Contributors</h3>
<p>The following people have contributed to fplll:</p>
<ul>
<li>Martin Albrecht</li>
<li>Shi Bai</li>
<li>Guillaume Bonnoron</li>
<li>David Cade</li>
<li>Léo Ducas</li>
<li>Joop van de Pol</li>
<li>Xavier Pujol</li>
<li>Damien Stehlé</li>
<li>Marc Stevens</li>
<li>Gilles Villard</li>
<li>Michael Walter</li>
</ul>
<p>Please add yourself here if you make a contribution.</p>
<h3>Acknowledgments</h3>
<ul>
<li>Patrick Pelissier and Paul Zimmermann for <code>dpe</code>.</li>
<li>David H. Bailey for <code>QD</code>.</li>
<li>Sylvain Chevillard, Christoph Lauter and Gilles Villard for the <code>configure/make/make install</code> packaging.</li>
<li>Timothy Abbott, Michael Abshoff, Bill Allombert, John Cannon, Sylvain Chevillard, Julien Clement, Andreas Enge, Jean-Pierre Flori, Laurent Fousse, Guillaume Hanrot, Jens Hermans, Jerry James, Christoph Lauter, Andrew Novocin, Willem Jan Palenstijn, Patrick Pelissier, Michael Schneider, Thiemo Seufer, Allan Steel, Gilles Villard and Paul Zimmermann for their support and for many suggestions that helped debugging and improving this code.</li>
<li><a class="el" href="md_CONTRIBUTING.html">CONTRIBUTING.md</a> is taken, almost verbatim, from <a href="https://github.com/pydanny/djangopackages/blob/master/docs/contributing.rst">https://github.com/pydanny/djangopackages/blob/master/docs/contributing.rst</a></li>
<li><a href="fplll/io/json.hpp">json.hpp</a> is taken from <a href="https://github.com/nlohmann/json">https://github.com/nlohmann/json</a></li>
<li>This project has been supported by ERC Starting Grant ERC-2013-StG-335086-LATTAC.</li>
</ul>
<h2>Contributing</h2>
<p>fplll welcomes contributions. See <a class="el" href="md_CONTRIBUTING.html">CONTRIBUTING.md</a> for details.</p>
<h2>New releases and bug reports</h2>
<p>New releases will be announced on <a href="https://groups.google.com/forum/#!forum/fplll-devel">https://groups.google.com/forum/#!forum/fplll-devel</a>.</p>
<p>Bug reports may be sent to <a href="https://groups.google.com/forum/#!forum/fplll-devel">https://groups.google.com/forum/#!forum/fplll-devel</a> or via <a href="https://github.com/fplll/fplll/issues">https://github.com/fplll/fplll/issues</a>. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 25 2016 16:07:06 for fplll by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
